import{a as F,_ as at,bc as ne,bd as O,be as Ft,an as ae,am as Y,h as bt,a3 as gt,ak as Dt,O as le,r as ue,G as fe,o as pe,Y as de,n as he,aH as We,ae as Ye,bf as Ze,bg as $e,aJ as Je,bh as Ke,bi as Qe,bj as tn,bk as en,aI as nn,bl as sn,bm as on,bn as rn,bo as cn,bp as an,bq as ye,a8 as me,br as xe}from"./index.ca3d1873.js";const se=0,we=1,Ae=2,Nt=2,Bt=1.25,qt=1,wt=6*4+4+4,zt=65535,be=Math.pow(2,-24);class ut{constructor(){}}function _(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Ht(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function Ot(n,t){t.set(n)}function kt(n,t,e){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=t[r],e[r]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function ft(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],r=t[n+2*s+1],o=i-r,l=i+r;o<e[s]&&(e[s]=o),l>e[s+3]&&(e[s+3]=l)}}function et(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function ge(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;e>65535?i=new Uint32Array(new s(4*e)):i=new Uint16Array(new s(2*e)),n.setIndex(new gt(i,1));for(let r=0;r<e;r++)i[r]=r}}function Te(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const i of n.groups)e.add(i.start),e.add(i.start+i.count);const s=Array.from(e.values()).sort((i,r)=>i-r);for(let i=0;i<s.length-1;i++){const r=s[i],o=s[i+1];t.push({offset:r/3,count:(o-r)/3})}return t}function St(n,t,e,s,i=null){let r=1/0,o=1/0,l=1/0,c=-1/0,u=-1/0,a=-1/0,f=1/0,p=1/0,d=1/0,b=-1/0,w=-1/0,A=-1/0;const y=i!==null;for(let m=t*6,h=(t+e)*6;m<h;m+=6){const x=n[m+0],g=n[m+1],T=x-g,S=x+g;T<r&&(r=T),S>c&&(c=S),y&&x<f&&(f=x),y&&x>b&&(b=x);const B=n[m+2],P=n[m+3],M=B-P,I=B+P;M<o&&(o=M),I>u&&(u=I),y&&B<p&&(p=B),y&&B>w&&(w=B);const v=n[m+4],z=n[m+5],U=v-z,C=v+z;U<l&&(l=U),C>a&&(a=C),y&&v<d&&(d=v),y&&v>A&&(A=v)}s[0]=r,s[1]=o,s[2]=l,s[3]=c,s[4]=u,s[5]=a,y&&(i[0]=f,i[1]=p,i[2]=d,i[3]=b,i[4]=w,i[5]=A)}function Pe(n,t,e,s){let i=1/0,r=1/0,o=1/0,l=-1/0,c=-1/0,u=-1/0;for(let a=t*6,f=(t+e)*6;a<f;a+=6){const p=n[a+0];p<i&&(i=p),p>l&&(l=p);const d=n[a+2];d<r&&(r=d),d>c&&(c=d);const b=n[a+4];b<o&&(o=b),b>u&&(u=b)}s[0]=i,s[1]=r,s[2]=o,s[3]=l,s[4]=c,s[5]=u}function Be(n,t,e,s,i){let r=e,o=e+s-1;const l=i.pos,c=i.axis*2;for(;;){for(;r<=o&&t[r*6+c]<l;)r++;for(;r<=o&&t[o*6+c]>=l;)o--;if(r<o){for(let u=0;u<3;u++){let a=n[r*3+u];n[r*3+u]=n[o*3+u],n[o*3+u]=a;let f=t[r*6+u*2+0];t[r*6+u*2+0]=t[o*6+u*2+0],t[o*6+u*2+0]=f;let p=t[r*6+u*2+1];t[r*6+u*2+1]=t[o*6+u*2+1],t[o*6+u*2+1]=p}r++,o--}else return r}}const H=32,Se=(n,t)=>n.candidate-t.candidate,G=new Array(H).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),pt=new Float32Array(6);function Me(n,t,e,s,i,r){let o=-1,l=0;if(r===se)o=Ht(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(r===we)o=Ht(n),o!==-1&&(l=Ie(e,s,i,o));else if(r===Ae){const c=et(n);let u=Bt*i;const a=s*6,f=(s+i)*6;for(let p=0;p<3;p++){const d=t[p],A=(t[p+3]-d)/H;if(i<H/4){const y=[...G];y.length=i;let m=0;for(let x=a;x<f;x+=6,m++){const g=y[m];g.candidate=e[x+2*p],g.count=0;const{bounds:T,leftCacheBounds:S,rightCacheBounds:B}=g;for(let P=0;P<3;P++)B[P]=1/0,B[P+3]=-1/0,S[P]=1/0,S[P+3]=-1/0,T[P]=1/0,T[P+3]=-1/0;ft(x,e,T)}y.sort(Se);let h=i;for(let x=0;x<h;x++){const g=y[x];for(;x+1<h&&y[x+1].candidate===g.candidate;)y.splice(x+1,1),h--}for(let x=a;x<f;x+=6){const g=e[x+2*p];for(let T=0;T<h;T++){const S=y[T];g>=S.candidate?ft(x,e,S.rightCacheBounds):(ft(x,e,S.leftCacheBounds),S.count++)}}for(let x=0;x<h;x++){const g=y[x],T=g.count,S=i-g.count,B=g.leftCacheBounds,P=g.rightCacheBounds;let M=0;T!==0&&(M=et(B)/c);let I=0;S!==0&&(I=et(P)/c);const v=qt+Bt*(M*T+I*S);v<u&&(o=p,u=v,l=g.candidate)}}else{for(let h=0;h<H;h++){const x=G[h];x.count=0,x.candidate=d+A+h*A;const g=x.bounds;for(let T=0;T<3;T++)g[T]=1/0,g[T+3]=-1/0}for(let h=a;h<f;h+=6){let T=~~((e[h+2*p]-d)/A);T>=H&&(T=H-1);const S=G[T];S.count++,ft(h,e,S.bounds)}const y=G[H-1];Ot(y.bounds,y.rightCacheBounds);for(let h=H-2;h>=0;h--){const x=G[h],g=G[h+1];kt(x.bounds,g.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let h=0;h<H-1;h++){const x=G[h],g=x.count,T=x.bounds,B=G[h+1].rightCacheBounds;g!==0&&(m===0?Ot(T,pt):kt(T,pt,pt)),m+=g;let P=0,M=0;m!==0&&(P=et(pt)/c);const I=i-m;I!==0&&(M=et(B)/c);const v=qt+Bt*(P*m+M*I);v<u&&(o=p,u=v,l=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:l}}function Ie(n,t,e,s){let i=0;for(let r=t,o=t+e;r<o;r++)i+=n[r*6+s*2];return i/e}function ve(n,t){const e=n.attributes.position,s=e.array,i=n.index.array,r=i.length/3,o=new Float32Array(r*6),l=e.offset||0;let c=3;e.isInterleavedBufferAttribute&&(c=e.data.stride);for(let u=0;u<r;u++){const a=u*3,f=u*6,p=i[a+0]*c+l,d=i[a+1]*c+l,b=i[a+2]*c+l;for(let w=0;w<3;w++){const A=s[p+w],y=s[d+w],m=s[b+w];let h=A;y<h&&(h=y),m<h&&(h=m);let x=A;y>x&&(x=y),m>x&&(x=m);const g=(x-h)/2,T=w*2;o[f+T+0]=h+g,o[f+T+1]=g+(Math.abs(h)+g)*be,h<t[w]&&(t[w]=h),x>t[w+3]&&(t[w+3]=x)}}return o}function Fe(n,t){function e(y){p&&p(y/d)}function s(y,m,h,x=null,g=0){if(!b&&g>=c&&(b=!0,u&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),h<=a||g>=c)return e(m),y.offset=m,y.count=h,y;const T=Me(y.boundingData,x,o,m,h,f);if(T.axis===-1)return e(m),y.offset=m,y.count=h,y;const S=Be(l,o,m,h,T);if(S===m||S===m+h)e(m),y.offset=m,y.count=h;else{y.splitAxis=T.axis;const B=new ut,P=m,M=S-m;y.left=B,B.boundingData=new Float32Array(6),St(o,P,M,B.boundingData,r),s(B,P,M,r,g+1);const I=new ut,v=S,z=h-M;y.right=I,I.boundingData=new Float32Array(6),St(o,v,z,I.boundingData,r),s(I,v,z,r,g+1)}return y}ge(n,t);const i=new Float32Array(6),r=new Float32Array(6),o=ve(n,i),l=n.index.array,c=t.maxDepth,u=t.verbose,a=t.maxLeafTris,f=t.strategy,p=t.onProgress,d=n.index.count/3;let b=!1;const w=[],A=Te(n);if(A.length===1){const y=A[0],m=new ut;m.boundingData=i,Pe(o,y.offset,y.count,r),s(m,y.offset,y.count,r),w.push(m)}else for(let y of A){const m=new ut;m.boundingData=new Float32Array(6),St(o,y.offset,y.count,m.boundingData,r),s(m,y.offset,y.count,r),w.push(m)}return w}function ze(n,t){const e=Fe(n,t);let s,i,r;const o=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const f=e[a];let p=c(f);const d=new l(wt*p);s=new Float32Array(d),i=new Uint32Array(d),r=new Uint16Array(d),u(0,f),o.push(d)}return o;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function u(a,f){const p=a/4,d=a/2,b=!!f.count,w=f.boundingData;for(let A=0;A<6;A++)s[p+A]=w[A];if(b){const A=f.offset,y=f.count;return i[p+6]=A,r[d+14]=y,r[d+15]=zt,a+wt}else{const A=f.left,y=f.right,m=f.splitAxis;let h;if(h=u(a+wt,A),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[p+6]=h/4,h=u(h,y),i[p+7]=m,h}}}class N{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const c=t[r][e];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const l=e[r],c=t.dot(l);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}N.prototype.setFromBox=function(){const n=new F;return function(e,s){const i=s.min,r=s.max;let o=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let a=0;a<=1;a++){n.x=i.x*c+r.x*(1-c),n.y=i.y*u+r.y*(1-u),n.z=i.z*a+r.z*(1-a);const f=e.dot(n);o=Math.min(f,o),l=Math.max(f,l)}this.min=o,this.max=l}}();(function(){const n=new N;return function(e,s){const i=e.points,r=e.satAxes,o=e.satBounds,l=s.points,c=s.satAxes,u=s.satBounds;for(let a=0;a<3;a++){const f=o[a],p=r[a];if(n.setFromPoints(p,l),f.isSeparated(n))return!1}for(let a=0;a<3;a++){const f=u[a],p=c[a];if(n.setFromPoints(p,i),f.isSeparated(n))return!1}}})();const Ce=function(){const n=new F,t=new F,e=new F;return function(i,r,o){const l=i.start,c=n,u=r.start,a=t;e.subVectors(l,u),n.subVectors(i.end,r.start),t.subVectors(r.end,r.start);const f=e.dot(a),p=a.dot(c),d=a.dot(a),b=e.dot(c),A=c.dot(c)*d-p*p;let y,m;A!==0?y=(f*p-b*d)/A:y=0,m=(f+y*p)/d,o.x=y,o.y=m}}(),Vt=function(){const n=new at,t=new F,e=new F;return function(i,r,o,l){Ce(i,r,n);let c=n.x,u=n.y;if(c>=0&&c<=1&&u>=0&&u<=1){i.at(c,o),r.at(u,l);return}else if(c>=0&&c<=1){u<0?r.at(0,l):r.at(1,l),i.closestPointToPoint(l,!0,o);return}else if(u>=0&&u<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,l);return}else{let a;c<0?a=i.start:a=i.end;let f;u<0?f=r.start:f=r.end;const p=t,d=e;if(i.closestPointToPoint(f,!0,t),r.closestPointToPoint(a,!0,e),p.distanceToSquared(f)<=d.distanceToSquared(a)){o.copy(p),l.copy(f);return}else{o.copy(a),l.copy(d);return}}}}(),Ee=function(){const n=new F,t=new F,e=new ne,s=new O;return function(r,o){const{radius:l,center:c}=r,{a:u,b:a,c:f}=o;if(s.start=u,s.end=a,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(s.start=u,s.end=f,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(s.start=a,s.end=f,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const w=o.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=l){const y=w.projectPoint(c,t);if(o.containsPoint(y))return!0}return!1}}();class k extends Ft{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new F),this.satBounds=new Array(4).fill().map(()=>new N),this.points=[this.a,this.b,this.c],this.sphere=new ae,this.plane=new ne,this.needsUpdate=!1}intersectsSphere(t){return Ee(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,l=r[0],c=o[0];this.getNormal(l),c.setFromPoints(l,i);const u=r[1],a=o[1];u.subVectors(t,e),a.setFromPoints(u,i);const f=r[2],p=o[2];f.subVectors(e,s),p.setFromPoints(f,i);const d=r[3],b=o[3];d.subVectors(s,t),b.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}k.prototype.closestPointToSegment=function(){const n=new F,t=new F,e=new O;return function(i,r=null,o=null){const{start:l,end:c}=i,u=this.points;let a,f=1/0;for(let p=0;p<3;p++){const d=(p+1)%3;e.start.copy(u[p]),e.end.copy(u[d]),Vt(e,i,n,t),a=n.distanceToSquared(t),a<f&&(f=a,r&&r.copy(n),o&&o.copy(t))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<f&&(f=a,r&&r.copy(n),o&&o.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<f&&(f=a,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(f)}}();k.prototype.intersectsTriangle=function(){const n=new k,t=new Array(3),e=new Array(3),s=new N,i=new N,r=new F,o=new F,l=new F,c=new F,u=new O,a=new O,f=new O;return function(d,b=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const w=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let h=0;h<4;h++){const x=w[h],g=A[h];if(s.setFromPoints(g,e),x.isSeparated(s))return!1}const y=d.satBounds,m=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let h=0;h<4;h++){const x=y[h],g=m[h];if(s.setFromPoints(g,t),x.isSeparated(s))return!1}for(let h=0;h<4;h++){const x=A[h];for(let g=0;g<4;g++){const T=m[g];if(r.crossVectors(x,T),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}if(b){const h=this.plane,x=d.plane;if(Math.abs(h.normal.dot(x.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),b.start.set(0,0,0),b.end.set(0,0,0);else{const g=this.points;let T=!1;for(let P=0;P<3;P++){const M=g[P],I=g[(P+1)%3];if(u.start.copy(M),u.end.copy(I),x.intersectLine(u,T?a.start:a.end)){if(T)break;T=!0}}const S=d.points;let B=!1;for(let P=0;P<3;P++){const M=S[P],I=S[(P+1)%3];if(u.start.copy(M),u.end.copy(I),h.intersectLine(u,B?f.start:f.end)){if(B)break;B=!0}}if(a.delta(o),f.delta(l),o.dot(l)<0){let P=f.start;f.start=f.end,f.end=P}c.subVectors(a.start,f.start),c.dot(o)>0?b.start.copy(a.start):b.start.copy(f.start),c.subVectors(a.end,f.end),c.dot(o)<0?b.end.copy(a.end):b.end.copy(f.end)}}return!0}}();k.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();k.prototype.distanceToTriangle=function(){const n=new F,t=new F,e=["a","b","c"],s=new O,i=new O;return function(o,l=null,c=null){const u=l||c?s:null;if(this.intersectsTriangle(o,u))return(l||c)&&(l&&u.getCenter(l),c&&u.getCenter(c)),0;let a=1/0;for(let f=0;f<3;f++){let p;const d=e[f],b=o[d];this.closestPointToPoint(b,n),p=b.distanceToSquared(n),p<a&&(a=p,l&&l.copy(n),c&&c.copy(b));const w=this[d];o.closestPointToPoint(w,n),p=w.distanceToSquared(n),p<a&&(a=p,l&&l.copy(w),c&&c.copy(n))}for(let f=0;f<3;f++){const p=e[f],d=e[(f+1)%3];s.set(this[p],this[d]);for(let b=0;b<3;b++){const w=e[b],A=e[(b+1)%3];i.set(o[w],o[A]),Vt(s,i,n,t);const y=n.distanceToSquared(t);y<a&&(a=y,l&&l.copy(n),c&&c.copy(t))}}return Math.sqrt(a)}}();class q extends Y{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new bt,this.invMatrix=new bt,this.points=new Array(8).fill().map(()=>new F),this.satAxes=new Array(3).fill().map(()=>new F),this.satBounds=new Array(3).fill().map(()=>new N),this.alignedSatBounds=new Array(3).fill().map(()=>new N),this.needsUpdate=!1}set(t,e,s){super.set(t,e),this.matrix=s,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let a=0;a<=1;a++)for(let f=0;f<=1;f++){const p=1*u|2*a|4*f,d=i[p];d.x=u?s.x:e.x,d.y=a?s.y:e.y,d.z=f?s.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,l=i[0];for(let u=0;u<3;u++){const a=o[u],f=r[u],p=1<<u,d=i[p];a.subVectors(l,d),f.setFromPoints(a,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const n=new N;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,l[0].isSeparated(n)||(n.min=s.y,n.max=i.y,l[1].isSeparated(n))||(n.min=s.z,n.max=i.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const u=o[c],a=r[c];if(n.setFromBox(u,e),a.isSeparated(n))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const n=new k,t=new Array(3),e=new N,s=new N,i=new F;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const l=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let p=0;p<3;p++){const d=l[p],b=c[p];if(e.setFromPoints(b,t),d.isSeparated(e))return!1}const u=o.satBounds,a=o.satAxes,f=this.points;for(let p=0;p<3;p++){const d=u[p],b=a[p];if(e.setFromPoints(b,f),d.isSeparated(e))return!1}for(let p=0;p<3;p++){const d=c[p];for(let b=0;b<4;b++){const w=a[b];if(i.crossVectors(d,w),e.setFromPoints(i,t),s.setFromPoints(i,f),e.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();q.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new O),e=new Array(12).fill().map(()=>new O),s=new F,i=new F;return function(o,l=0,c=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||u)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),u&&u.copy(i)),0;const a=l*l,f=o.min,p=o.max,d=this.points;let b=1/0;for(let A=0;A<8;A++){const y=d[A];i.copy(y).clamp(f,p);const m=y.distanceToSquared(i);if(m<b&&(b=m,c&&c.copy(y),u&&u.copy(i),m<a))return Math.sqrt(m)}let w=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){const h=(A+1)%3,x=(A+2)%3,g=y<<h|m<<x,T=1<<A|y<<h|m<<x,S=d[g],B=d[T];t[w].set(S,B);const M=n[A],I=n[h],v=n[x],z=e[w],U=z.start,C=z.end;U[M]=f[M],U[I]=y?f[I]:p[I],U[v]=m?f[v]:p[I],C[M]=p[M],C[I]=y?f[I]:p[I],C[v]=m?f[v]:p[I],w++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){i.x=A?p.x:f.x,i.y=y?p.y:f.y,i.z=m?p.z:f.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<b&&(b=h,c&&c.copy(s),u&&u.copy(i),h<a))return Math.sqrt(h)}for(let A=0;A<12;A++){const y=t[A];for(let m=0;m<12;m++){const h=e[m];Vt(y,h,s,i);const x=s.distanceToSquared(i);if(x<b&&(b=x,c&&c.copy(s),u&&u.copy(i),x<a))return Math.sqrt(x)}}return Math.sqrt(b)}}();const dt=new F,ht=new F,yt=new F,Gt=new at,jt=new at,Xt=new at,Wt=new F;function Ue(n,t,e,s,i,r){let o;return r===ye?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,r!==me,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Ve(n,t,e,s,i,r,o){dt.fromBufferAttribute(t,s),ht.fromBufferAttribute(t,i),yt.fromBufferAttribute(t,r);const l=Ue(n,dt,ht,yt,Wt,o);if(l){e&&(Gt.fromBufferAttribute(e,s),jt.fromBufferAttribute(e,i),Xt.fromBufferAttribute(e,r),l.uv=Ft.getUV(Wt,dt,ht,yt,Gt,jt,Xt,new at));const c={a:s,b:i,c:r,normal:new F,materialIndex:0};Ft.getNormal(dt,ht,yt,c.normal),l.face=c,l.faceIndex=s}return l}function ie(n,t,e,s,i){const r=s*3,o=n.index.getX(r),l=n.index.getX(r+1),c=n.index.getX(r+2),u=Ve(e,n.attributes.position,n.attributes.uv,o,l,c,t);return u?(u.faceIndex=s,i&&i.push(u),u):null}function Re(n,t,e,s,i,r){for(let o=s,l=s+i;o<l;o++)ie(n,t,e,o,r)}function _e(n,t,e,s,i){let r=1/0,o=null;for(let l=s,c=s+i;l<c;l++){const u=ie(n,t,e,l);u&&u.distance<r&&(o=u,r=u.distance)}return o}function oe(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}function D(n,t,e,s){const i=n.a,r=n.b,o=n.c;let l=t,c=t+1,u=t+2;e&&(l=e.getX(t),c=e.getX(t+1),u=e.getX(t+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(u),o.y=s.getY(u),o.z=s.getZ(u)}function Yt(n,t,e,s,i,r,o){const l=e.index,c=e.attributes.position;for(let u=n,a=t+n;u<a;u++)if(D(o,u*3,l,c),o.needsUpdate=!0,s(o,u,i,r))return!0;return!1}class re{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function j(n,t){return t[n+15]===65535}function Q(n,t){return t[n+6]}function ot(n,t){return t[n+14]}function rt(n){return n+8}function ct(n,t){return t[n+6]}function Le(n,t){return t[n+7]}const K=new Y,Tt=new F,De=["x","y","z"];function Ct(n,t,e,s,i){let r=n*2,o=tt,l=X,c=W;if(j(r,l)){const a=Q(n,c),f=ot(r,l);Re(t,e,s,a,f,i)}else{const a=rt(n);Pt(a,o,s,Tt)&&Ct(a,t,e,s,i);const f=ct(n,c);Pt(f,o,s,Tt)&&Ct(f,t,e,s,i)}}function Et(n,t,e,s){let i=n*2,r=tt,o=X,l=W;if(j(i,o)){const u=Q(n,l),a=ot(i,o);return _e(t,e,s,u,a)}else{const u=Le(n,l),a=De[u],p=s.direction[a]>=0;let d,b;p?(d=rt(n),b=ct(n,l)):(d=ct(n,l),b=rt(n));const A=Pt(d,r,s,Tt)?Et(d,t,e,s):null;if(A){const h=A.point[a];if(p?h<=r[b+u]:h>=r[b+u+3])return A}const m=Pt(b,r,s,Tt)?Et(b,t,e,s):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const Ne=function(){let n,t;const e=[],s=new re(()=>new Y);return function(...o){n=s.getPrimitive(),t=s.getPrimitive(),e.push(n,t);const l=i(...o);s.releasePrimitive(n),s.releasePrimitive(t),e.pop(),e.pop();const c=e.length;return c>0&&(t=e[c-1],n=e[c-2]),l};function i(r,o,l,c,u=null,a=0,f=0){function p(h){let x=h*2,g=X,T=W;for(;!j(x,g);)h=rt(h),x=h*2;return Q(h,T)}function d(h){let x=h*2,g=X,T=W;for(;!j(x,g);)h=ct(h,T),x=h*2;return Q(h,T)+ot(x,g)}let b=r*2,w=tt,A=X,y=W;if(j(b,A)){const h=Q(r,y),x=ot(b,A);return _(r,w,n),c(h,x,!1,f,a+r,n)}else{const h=rt(r),x=ct(r,y);let g=h,T=x,S,B,P,M;if(u&&(P=n,M=t,_(g,w,P),_(T,w,M),S=u(P),B=u(M),B<S)){g=x,T=h;const R=S;S=B,B=R,P=M}P||(P=n,_(g,w,P));const I=j(g*2,A),v=l(P,I,S,f+1,a+g);let z;if(v===Nt){const R=p(g),$=d(g)-R;z=c(R,$,!0,f+1,a+g,P)}else z=v&&i(g,o,l,c,u,a,f+1);if(z)return!0;M=t,_(T,w,M);const U=j(T*2,A),C=l(M,U,B,f+1,a+T);let V;if(C===Nt){const R=p(T),$=d(T)-R;V=c(R,$,!0,f+1,a+T,M)}else V=C&&i(T,o,l,c,u,a,f+1);return!!V}}}(),qe=function(){const n=new k,t=new k,e=new bt,s=new q,i=new q;return function r(o,l,c,u,a=null){let f=o*2,p=tt,d=X,b=W;if(a===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,u),a=s),j(f,d)){const A=l,y=A.index,m=A.attributes.position,h=c.index,x=c.attributes.position,g=Q(o,b),T=ot(f,d);if(e.copy(u).invert(),c.boundsTree)return _(o,p,i),i.matrix.copy(e),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>i.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(u),B.b.applyMatrix4(u),B.c.applyMatrix4(u),B.needsUpdate=!0;for(let P=g*3,M=(T+g)*3;P<M;P+=3)if(D(t,P,y,m),t.needsUpdate=!0,B.intersectsTriangle(t))return!0;return!1}});for(let S=g*3,B=T+g*3;S<B;S+=3){D(n,S,y,m),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let P=0,M=h.count;P<M;P+=3)if(D(t,P,h,x),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const A=o+8,y=b[o+6];return _(A,p,K),!!(a.intersectsBox(K)&&r(A,l,c,u,a)||(_(y,p,K),a.intersectsBox(K)&&r(y,l,c,u,a)))}}}();function Pt(n,t,e,s){return _(n,t,K),e.intersectBox(K,s)}const Ut=[];let At,tt,X,W;function it(n){At&&Ut.push(At),At=n,tt=new Float32Array(n),X=new Uint16Array(n),W=new Uint32Array(n)}function mt(){At=null,tt=null,X=null,W=null,Ut.length&&it(Ut.pop())}const Mt=Symbol("skip tree generation"),It=new Y,vt=new Y,J=new bt,Z=new q,nt=new q,st=new F,xt=new F,He=new F,Oe=new F,ke=new F,Zt=new Y,L=new re(()=>new k);class E{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),E.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=s.getIndex();let o;return e.cloneBuffers?o={roots:i.map(l=>l.slice()),index:r.array.slice()}:o={roots:i,index:r.array},o}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),E.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:i,roots:r}=t,o=new E(e,{...s,[Mt]:!0});if(o._roots=r,s.setIndex){const l=e.getIndex();if(l===null){const c=new gt(t.index,1,!1);e.setIndex(c)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return o}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:se,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Mt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Mt]||(this._roots=ze(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,i=e.attributes.position,r=i.array,o=i.offset||0;let l=3;i.isInterleavedBufferAttribute&&(l=i.data.stride);let c,u,a,f,p=0;const d=this._roots;for(let w=0,A=d.length;w<A;w++)c=d[w],u=new Uint32Array(c),a=new Uint16Array(c),f=new Float32Array(c),b(0,p),p+=c.byteLength;function b(w,A,y=!1){const m=w*2;if(a[m+15]===zt){const x=u[w+6],g=a[m+14];let T=1/0,S=1/0,B=1/0,P=-1/0,M=-1/0,I=-1/0;for(let v=3*x,z=3*(x+g);v<z;v++){const U=s[v]*l+o,C=r[U+0],V=r[U+1],R=r[U+2];C<T&&(T=C),C>P&&(P=C),V<S&&(S=V),V>M&&(M=V),R<B&&(B=R),R>I&&(I=R)}return f[w+0]!==T||f[w+1]!==S||f[w+2]!==B||f[w+3]!==P||f[w+4]!==M||f[w+5]!==I?(f[w+0]=T,f[w+1]=S,f[w+2]=B,f[w+3]=P,f[w+4]=M,f[w+5]=I,!0):!1}else{const x=w+8,g=u[w+6],T=x+A,S=g+A;let B=y,P=!1,M=!1;t?B||(P=t.has(T),M=t.has(S),B=!P&&!M):(P=!0,M=!0);const I=B||P,v=B||M;let z=!1;I&&(z=b(x,A,B));let U=!1;v&&(U=b(g,A,B));const C=z||U;if(C)for(let V=0;V<3;V++){const R=x+V,lt=g+V,$=f[R],Rt=f[R+3],_t=f[lt],Lt=f[lt+3];f[w+V]=$<_t?$:_t,f[w+V+3]=Rt>Lt?Rt:Lt}return C}}}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(l,c=0){const u=l*2,a=r[u+15]===zt;if(a){const f=i[l+6],p=r[u+14];t(c,a,new Float32Array(s,l*4,6),f,p)}else{const f=l+wt/4,p=i[l+6],d=i[l+7];t(c,a,new Float32Array(s,l*4,6),d)||(o(f,c+1),o(p,c+1))}}}raycast(t,e=Dt){const s=this._roots,i=this.geometry,r=[],o=e.isMaterial,l=Array.isArray(e),c=i.groups,u=o?e.side:e;for(let a=0,f=s.length;a<f;a++){const p=l?e[c[a].materialIndex].side:u,d=r.length;if(it(s[a]),Ct(0,i,p,t,r),mt(),l){const b=c[a].materialIndex;for(let w=d,A=r.length;w<A;w++)r[w].face.materialIndex=b}}return r}raycastFirst(t,e=Dt){const s=this._roots,i=this.geometry,r=e.isMaterial,o=Array.isArray(e);let l=null;const c=i.groups,u=r?e.side:e;for(let a=0,f=s.length;a<f;a++){const p=o?e[c[a].materialIndex].side:u;it(s[a]);const d=Et(0,i,p,t);mt(),d!=null&&(l==null||d.distance<l.distance)&&(l=d,o&&(d.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){const s=this.geometry;let i=!1;for(const r of this._roots)if(it(r),i=qe(0,s,t,e),mt(),i)break;return i}shapecast(t,e,s){const i=this.geometry;if(t instanceof Function){if(e){const p=e;e=(d,b,w,A)=>{const y=b*3;return p(d,y,y+1,y+2,w,A)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=L.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:l,intersectsRange:c,intersectsTriangle:u}=t;if(c&&u){const p=c;c=(d,b,w,A,y)=>p(d,b,w,A,y)?!0:Yt(d,b,i,u,w,A,r)}else c||(u?c=(p,d,b,w)=>Yt(p,d,i,u,b,w,r):c=(p,d,b)=>b);let a=!1,f=0;for(const p of this._roots){if(it(p),a=Ne(0,i,l,c,o,f),mt(),a)break;f+=p.byteLength}return L.releasePrimitive(r),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=this.geometry.index,l=this.geometry.attributes.position,c=t.geometry.index,u=t.geometry.attributes.position;J.copy(e).invert();const a=L.getPrimitive(),f=L.getPrimitive();if(r){let d=function(b,w,A,y,m,h,x,g){for(let T=A,S=A+y;T<S;T++){D(f,T*3,c,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let B=b,P=b+w;B<P;B++)if(D(a,B*3,o,l),a.needsUpdate=!0,r(a,f,B,T,m,h,x,g))return!0}return!1};if(i){const b=i;i=function(w,A,y,m,h,x,g,T){return b(w,A,y,m,h,x,g,T)?!0:d(w,A,y,m,h,x,g,T)}}else i=d}this.getBoundingBox(vt),vt.applyMatrix4(e);const p=this.shapecast({intersectsBounds:d=>vt.intersectsBox(d),intersectsRange:(d,b,w,A,y,m)=>(It.copy(m),It.applyMatrix4(J),t.shapecast({intersectsBounds:h=>It.intersectsBox(h),intersectsRange:(h,x,g,T,S)=>i(d,b,h,x,A,y,T,S)}))});return L.releasePrimitive(a),L.releasePrimitive(f),p}intersectsBox(t,e){return Z.set(t.min,t.max,e),Z.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Z.intersectsBox(s),intersectsTriangle:s=>Z.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Z.set(t.boundingBox.min,t.boundingBox.max,e),Z.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,u=l.index,a=t.attributes.position,f=t.index,p=L.getPrimitive(),d=L.getPrimitive();let b=xt,w=He,A=null,y=null;i&&(A=Oe,y=ke);let m=1/0,h=null,x=null;return J.copy(e).invert(),nt.matrix.copy(J),this.shapecast({boundsTraverseOrder:g=>Z.distanceToBox(g,Math.min(m,o)),intersectsBounds:(g,T,S)=>S<m&&S<o?(T&&(nt.min.copy(g.min),nt.max.copy(g.max),nt.needsUpdate=!0),!0):!1,intersectsRange:(g,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:S=>nt.distanceToBox(S,Math.min(m,o)),intersectsBounds:(S,B,P)=>P<m&&P<o,intersectsRange:(S,B)=>{for(let P=S*3,M=(S+B)*3;P<M;P+=3){D(d,P,f,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let I=g*3,v=(g+T)*3;I<v;I+=3){D(p,I,u,c),p.needsUpdate=!0;const z=p.distanceToTriangle(d,b,A);if(z<m&&(w.copy(b),y&&y.copy(A),m=z,h=I/3,x=P/3),z<r)return!0}}}});{const S=f?f.count:a.count;for(let B=0,P=S;B<P;B+=3){D(d,B,f,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let M=g*3,I=(g+T)*3;M<I;M+=3){D(p,M,u,c),p.needsUpdate=!0;const v=p.distanceToTriangle(d,b,A);if(v<m&&(w.copy(b),y&&y.copy(A),m=v,h=M/3,x=B/3),v<r)return!0}}}}}),L.releasePrimitive(p),L.releasePrimitive(d),m===1/0?null:(s.point?s.point.copy(w):s.point=w.clone(),s.distance=m,s.faceIndex=h,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(J),w.applyMatrix4(J),i.distance=w.sub(i.point).length(),i.faceIndex=x),s)}closestPointToPoint(t,e={},s=0,i=1/0){const r=s*s,o=i*i;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(st.copy(t).clamp(a.min,a.max),st.distanceToSquared(t)),intersectsBounds:(a,f,p)=>p<l&&p<o,intersectsTriangle:(a,f)=>{a.closestPointToPoint(t,st);const p=t.distanceToSquared(st);return p<l&&(xt.copy(st),l=p,c=f),p<r}}),l===1/0)return null;const u=Math.sqrt(l);return e.point?e.point.copy(xt):e.point=xt.clone(),e.distance=u,e.faceIndex=c,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{_(0,new Float32Array(s),Zt),t.union(Zt)}),t}}const $t=E.prototype.raycast;E.prototype.raycast=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[t,e,s,i]=n;return $t.call(this,s,t.material).forEach(o=>{o=oe(o,t,e),o&&i.push(o)}),i}else return $t.apply(this,n)};const Jt=E.prototype.raycastFirst;E.prototype.raycastFirst=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[t,e,s]=n;return oe(Jt.call(this,s,t.material),t,e)}else return Jt.apply(this,n)};const Kt=E.prototype.closestPointToPoint;E.prototype.closestPointToPoint=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),n.unshift();const t=n[1],e={};return n[1]=e,Kt.apply(this,n),t&&t.copy(e.point),e.distance}else return Kt.apply(this,n)};const Qt=E.prototype.closestPointToGeometry;E.prototype.closestPointToGeometry=function(...n){const t=n[2],e=n[3];if(t&&t.isVector3||e&&e.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const s={},i={},r=n[1];return n[2]=s,n[3]=i,Qt.apply(this,n),t&&t.copy(s.point),e&&e.copy(i.point).applyMatrix4(r),s.distance}else return Qt.apply(this,n)};const te=E.prototype.refit;E.prototype.refit=function(...n){const t=n[0],e=n[1];if(e&&(e instanceof Set||Array.isArray(e))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const s=new Set;e.forEach(i=>s.add(i)),t&&t.forEach(i=>s.add(i)),te.call(this,s)}else te.apply(this,n)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(n=>{const t=E.prototype[n];E.prototype[n]=function(...e){return(e[0]===null||e[0].isMesh)&&(e.shift(),console.warn(`MeshBVH: The function signature for "${n}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,e)}});const ee=new Y;class Ge extends le{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,i=0){super(),this.material=e,this.geometry=new ue,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,r=this.displayParents;let o=0;e.traverse((p,d)=>{if(p===i||d)return o++,!0;r&&o++},s);let l=0;const c=new Float32Array(8*3*o);e.traverse((p,d,b)=>{const w=p===i||d;if(w||r){_(0,b,ee);const{min:A,max:y}=ee;for(let m=-1;m<=1;m+=2){const h=m<0?A.x:y.x;for(let x=-1;x<=1;x+=2){const g=x<0?A.y:y.y;for(let T=-1;T<=1;T+=2){const S=T<0?A.z:y.z;c[l+0]=h,c[l+1]=g,c[l+2]=S,l+=3}}}return w}},s);let u,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c.length>65535?u=new Uint32Array(a.length*o):u=new Uint16Array(a.length*o);const f=a.length;for(let p=0;p<o;p++){const d=p*8,b=p*f;for(let w=0;w<f;w++)u[b+w]=d+a[w]}t.setIndex(new gt(u,1,!1)),t.setAttribute("position",new gt(c,3,!1)),this.visible=!0}}}class ce extends fe{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new pe({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new de({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=s.color,this.edgeMaterial=s,this.meshMaterial=i,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let s=0;s<e;s++){if(s>=this._roots.length){const r=new Ge(this.mesh,this.edgeMaterial,this.depth,s);this.add(r),this._roots.push(r)}const i=this._roots[s];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new ce(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}he.prototype.raycast;const je=new WeakMap,ln=n=>{n.outerObject3d.updateMatrixWorld(!0);const t=[];n.outerObject3d.traverse(s=>{if(!s.geometry||s===n.nativeObject3d&&!(n instanceof xe))return;const i=s.geometry.clone();i.applyMatrix4(s.matrixWorld),t.push(i),i.dispose()});const e=[];for(const s of t){const i=s.boundsTree=new E(s);e.push(i),je.set(i,n)}return[e,t]};export{ce as M,je as b,ln as c};
